package com.dataart.advanced.task;

import java.io.*;
import java.util.Map;

import static com.dataart.advanced.task.Info.DEFAULT_ID;
import static com.dataart.advanced.task.Info.DEFAULT_SZ;
import static com.dataart.advanced.task.Info.SYMBOL_SUBSTITUTION;

/**
 * Commands exchange protocol implementation.
 * The command format is:
 * - 4 bytes -> length of text message in bytes. Should be read first via
 *              "readInt()";
 * - 4 bytes -> client's ID assigned by server after connection;
 * - variable number of bytes -> message content.
 * Supports multi-line commands.
 *
 * @author Sergey Sokhnyshev
 * Created on 01.07.16.
 */
class MessageTraits {
    private int clientID = DEFAULT_ID;  // client's identification number
    private String message;             // message content

    /**
     * Assigns client's identification number to message
     * @param clientID - client's identification number generated by server
     */
    void setClientID(int clientID) {
        this.clientID = clientID;
    }

    /**
     * Assigns message content and replaces service symbols with its
     * correct values
     * @param message - message content
     */
    void setMessage(String message) {
        // searching for service symbols
        StringBuilder buffer = new StringBuilder(message);

        for (Map.Entry<String, String> entry : SYMBOL_SUBSTITUTION.entrySet()) {
            int findIndex = 0;

            while ((findIndex = buffer.indexOf(entry.getKey(), findIndex)) != -1) {
                buffer.replace(findIndex, findIndex + entry.getKey().length(), entry.getValue());
            }
        }

        this.message = buffer.toString();
    }

    /**
     * @return client's identification number stored in message
     */
    final int getClientID() {
        return clientID;
    }

    /**
     * @return message content
     */
    final String getMessage() {
        return message;
    }

    /**
     * Packs message parameters to specified output stream
     * @param oos - external output stream connected to socket in client/server
     */
    void send(ObjectOutputStream oos) throws IOException {
        oos.writeInt(message.length());
        oos.writeInt(clientID);
        oos.write(message.getBytes());

        oos.flush();
    }

    /**
     * Extracts message from specified input stream
     * @param ois - external input stream connected to socket in client/server
     * @return - size of text message content or DEFAULT_SZ in failure case
     */
    int receive(ObjectInputStream ois) throws IOException {
        int readSz = DEFAULT_SZ;

        try {
            // getting message size
            int messageSz = ois.readInt();

            clientID = ois.readInt();

            // getting message content from input stream
            byte[] messageContent = new byte[messageSz];

            if((readSz = ois.read(messageContent)) != messageSz) {
                throw new IOException("MessageTraits.receive: mismatch of declared (" + messageSz + " bytes) " +
                                      "and obtained (" + readSz + " bytes) sizes of message");
            }

            message = new String(messageContent);
        } catch (EOFException exc) {
            return DEFAULT_SZ;
        }

        return readSz;
    }
}
