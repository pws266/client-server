package advanced.task;

import java.io.*;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

import static advanced.task.Info.DEFAULT_ID;
import static advanced.task.Info.DEFAULT_SZ;
import static advanced.task.Info.SYMBOL_SUBSTITUTION;

/**
 * Commands exchange protocol implementation.
 * The command format is:
 * - 4 bytes -> length of text message in bytes. Should be read first via
 *              "readInt()";
 * - 4 bytes -> client's ID assigned by server after connection;
 * - variable number of bytes -> message content.
 * Supports multi-line commands.
 *
 * @author Sergey Sokhnyshev
 * Created on 01.07.16.
 */
class MessageTraits {
    private int clientID = DEFAULT_ID;  // client's identification number
    private String message;             // message content

    // logger for tracing error messages
    private static final Logger log =
                                Logger.getLogger(MessageTraits.class.getName());
    /**
     * Assigns client's identification number to message
     * @param clientID - client's identification number generated by server
     */
    void setClientID(int clientID) {
        this.clientID = clientID;
    }

    /**
     * Assigns message content and replaces service symbols with its
     * correct values
     * @param message - message content
     */
    void setMessage(String message) {
        // searching for service symbols
        StringBuilder buffer = new StringBuilder(message);

        for (Map.Entry<String, String> entry : SYMBOL_SUBSTITUTION.entrySet()) {
            int findIndex = 0;

            while ((findIndex = buffer.indexOf(entry.getKey(),
                    findIndex)) != -1) {
                buffer.replace(findIndex,
                        findIndex + entry.getKey().length(),
                        entry.getValue());
            }
        }

        this.message = buffer.toString();
    }

    /**
     * @return client's identification number stored in message
     */
    final int getClientID() {
        return clientID;
    }

    /**
     * @return message content
     */
    final String getMessage() {
        return message;
    }

    /**
     * Packs message parameters to specified output stream
     * @param oos - external output stream connected to socket in client/server
     */
    void send(ObjectOutputStream oos) {
        try {
            oos.writeInt(message.length());
            oos.writeInt(clientID);
            oos.write(message.getBytes());

            oos.flush();
        } catch (IOException exc) {
            log.log(Level.SEVERE, "MessageTraits: unable to write message " +
                                  "to output stream", exc);
        }
    }

    /**
     * Extracts message from specified input stream
     * @param ois - external input stream connected to socket in client/server
     * @return - size of text message content or DEFAULT_SZ in failure case
     */
    int receive(ObjectInputStream ois) {
        int readSz = DEFAULT_SZ;

        try {
            // getting message size
            int messageSz = ois.readInt();

            clientID = ois.readInt();

            // getting message content from input stream
            byte[] messageContent = new byte[messageSz];

            try {
                if((readSz = ois.read(messageContent)) != messageSz) {
                    throw new Exception("Command: declared command size doesn't " +
                            "correspond to read body size");
                }
            } catch (Exception exc) {
                log.log(Level.SEVERE, "MessageTraits: mismatch of declared (" +
                                      messageSz + " bytes) and obtained (" +
                                      readSz + " bytes) sizes of message", exc);
            }

            message = new String(messageContent);
        } catch (EOFException exc) {
            return DEFAULT_SZ;
        } catch (IOException exc) {
            log.log(Level.SEVERE, "MessageTraits: unable to read message " +
                                  "from input stream", exc);
        }

        return readSz;
    }
}

